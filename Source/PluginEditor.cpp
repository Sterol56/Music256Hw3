/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "stk/ADSR.h"
#include "stk/BlitSaw.h" 

//==============================================================================
// This is a handy slider subclass that controls an AudioProcessorParameter
// (may move this class into the library itself at some point in the future..)
class JuceDemoPluginAudioProcessorEditor::ParameterSlider   : public Slider,
                                                              private Timer
{
public:
    ParameterSlider (AudioProcessorParameter& p)
        : Slider (p.getName (256)), param (p)
    {
        setRange (0.0, 1.0, 0.0);
        startTimerHz (30);
        updateSliderPos();
    }

    void valueChanged() override
    {
        if (isMouseButtonDown())
            param.setValueNotifyingHost ((float) Slider::getValue());
        else
            param.setValue ((float) Slider::getValue());
    }

    void timerCallback() override       { updateSliderPos(); }

    void startedDragging() override     { param.beginChangeGesture(); }
    void stoppedDragging() override     { param.endChangeGesture();   }

    double getValueFromText (const String& text) override   { return param.getValueForText (text); }
    String getTextFromValue (double value) override         { return param.getText ((float) value, 1024); }

    void updateSliderPos()
    {
        const float newValue = param.getValue();

        if (newValue != (float) Slider::getValue() && ! isMouseButtonDown())
            Slider::setValue (newValue);
    }

    AudioProcessorParameter& param;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ParameterSlider)
};

//==============================================================================
JuceDemoPluginAudioProcessorEditor::JuceDemoPluginAudioProcessorEditor (JuceDemoPluginAudioProcessor& owner)
    : AudioProcessorEditor (owner),
      midiKeyboard (owner.keyboardState, MidiKeyboardComponent::horizontalKeyboard),
      timecodeDisplayLabel (String()),
      gainLabel (String(), "Gain:"),
      delayLabel (String(), "Delay:"), 
		sawLabel(String(), "Saw:"),
		sineLabel(String(), "Sine:")
{
    // add some sliders..
    addAndMakeVisible (gainSlider = new ParameterSlider (*owner.gainParam));
    gainSlider->setSliderStyle (Slider::Rotary);
	gainSlider->setColour(Slider::rotarySliderFillColourId, Colours::orange);
	gainSlider->setColour(Slider::rotarySliderOutlineColourId, Colours::orange);

    addAndMakeVisible (delaySlider = new ParameterSlider (*owner.delayParam));
    delaySlider->setSliderStyle (Slider::Rotary);
	delaySlider->setColour(Slider::rotarySliderFillColourId, Colours::orange);
	delaySlider->setColour(Slider::rotarySliderOutlineColourId, Colours::orange);

	//addandmakevisible(sawslider = new parameterslider(*owner.onsawparam));
	//sawslider->setsliderstyle(slider::rotary);

	//addAndMakeVisible(sawSlider = new ParameterSlider(*owner.onSawParam));
	//sawSlider->setSliderStyle(Slider::Rotary);
	//sawSlider->setRange(0, 1, 1);
	//sawSlider->setTextBoxStyle(Slider::NoTextBox, false, 0, 0);

	addAndMakeVisible(sineLabel);
	addAndMakeVisible(sawLabel);
	//sawSlider.addListener(this);


	sineLabel.attachToComponent(sawSlider, true);

	
	sawLabel.attachToComponent(sawSlider, true);

    // add some labels for the sliders..
    gainLabel.attachToComponent (gainSlider, true);
    gainLabel.setFont (Font (11.0f));

    delayLabel.attachToComponent (delaySlider, true);
    delayLabel.setFont (Font (11.0f));

	//newLabel.attachToComponent(newSlider, true);
	//newLabel.setFont(Font(11.0f));

    // add the midi keyboard component..
    addAndMakeVisible (midiKeyboard);

    // add a label that will display the current timecode and status..
    addAndMakeVisible (timecodeDisplayLabel);
    timecodeDisplayLabel.setColour (Label::textColourId, Colours::red);
    timecodeDisplayLabel.setFont (Font (Font::getDefaultMonospacedFontName(), 15.0f, Font::plain));

    // set resize limits for this plug-in
    setResizeLimits (400, 200, 800, 300);



    // set our component's initial size to be the last one that was stored in the filter's settings
    setSize (400,
             300);

    // start a timer which will keep our timecode display updated
    startTimerHz (30);
}

JuceDemoPluginAudioProcessorEditor::~JuceDemoPluginAudioProcessorEditor()
{
}

//==============================================================================
void JuceDemoPluginAudioProcessorEditor::paint (Graphics& g)
{
	Image img = ImageCache::getFromMemory(BinaryData::background_png, BinaryData::background_pngSize);
	g.drawImageAt(img, 0, 0, false);
}

void JuceDemoPluginAudioProcessorEditor::resized()
{
    // This lays out our child components...

    Rectangle<int> r (getLocalBounds().reduced (8));

    timecodeDisplayLabel.setBounds (r.removeFromTop (26));
    midiKeyboard.setBounds (r.removeFromBottom (70));

    r.removeFromTop (30);
    Rectangle<int> sliderArea (r.removeFromTop (50));
    gainSlider->setBounds (40, 10, 150, 150);
    delaySlider->setBounds (240, 10, 150, 150);
    getProcessor().lastUIWidth = getWidth();
    getProcessor().lastUIHeight = getHeight();
}

//==============================================================================
void JuceDemoPluginAudioProcessorEditor::timerCallback()
{
    updateTimecodeDisplay (getProcessor().lastPosInfo);
}

//==============================================================================
// quick-and-dirty function to format a timecode string
static String timeToTimecodeString (double seconds)
{
    const int millisecs = roundToInt (seconds * 1000.0);
    const int absMillisecs = std::abs (millisecs);

    return String::formatted ("%02d:%02d:%02d.%03d",
                              millisecs / 360000,
                              (absMillisecs / 60000) % 60,
                              (absMillisecs / 1000) % 60,
                              absMillisecs % 1000);
}

// quick-and-dirty function to format a bars/beats string
static String quarterNotePositionToBarsBeatsString (double quarterNotes, int numerator, int denominator)
{
    if (numerator == 0 || denominator == 0)
        return "1|1|000";

    const int quarterNotesPerBar = (numerator * 4 / denominator);
    const double beats  = (fmod (quarterNotes, quarterNotesPerBar) / quarterNotesPerBar) * numerator;

    const int bar    = ((int) quarterNotes) / quarterNotesPerBar + 1;
    const int beat   = ((int) beats) + 1;
    const int ticks  = ((int) (fmod (beats, 1.0) * 960.0 + 0.5));

    return String::formatted ("%d|%d|%03d", bar, beat, ticks);
}

// Updates the text in our position label.
void JuceDemoPluginAudioProcessorEditor::updateTimecodeDisplay (AudioPlayHead::CurrentPositionInfo pos)
{
    MemoryOutputStream displayText;

	displayText << "What The Duck";


    timecodeDisplayLabel.setText (displayText.toString(), dontSendNotification);
}
void JuceDemoPluginAudioProcessorEditor::buttonClicked(Button*) {
	
}
void JuceDemoPluginAudioProcessorEditor::buttonStateChanged(Button *) {

}

void JuceDemoPluginAudioProcessorEditor::ParameterSlider::Listener::sliderValueChanged(Slider *)
{

}